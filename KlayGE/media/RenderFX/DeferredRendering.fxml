<?xml version='1.0'?>

<effect>
	<include name="DeferredRenderingUtil.fxml"/>
	<include name="Lighting.fxml"/>
	<include name="util.fxml"/>

	<parameter type="float" name="esm_scale_factor"/>

	<cbuffer name="light_sources">
		<parameter type="float4x4" name="light_view_proj"/>
		<parameter type="float4x4" name="light_volume_mv"/>
		<parameter type="float4x4" name="light_volume_mvp"/>
		<parameter type="float4x4" name="view_to_light_model"/>
		<parameter type="float4" name="light_color"/>
		<parameter type="float4" name="light_pos_es"/>
		<parameter type="float4" name="light_dir_es"/>
		<parameter type="float4" name="light_falloff_range"/>
		<parameter type="float4" name="light_attrib"/>
		<parameter type="float4" name="light_radius_extend"/>
	</cbuffer>

	<cbuffer name="cascaded_light_sources">
		<parameter type="float4" name="view_z_to_light_view"/>
		<parameter type="float4" name="cascade_scale_bias" array_size="4"/>
		<parameter type="float2" name="cascade_intervals" array_size="4"/>
		<parameter type="int" name="num_cascades"/>
	</cbuffer>

	<parameter type="texture2D" name="filtered_shadow_map_2d_tex"/>
	<parameter type="texture2DArray" name="filtered_shadow_map_2d_tex_array"/>
	<parameter type="int" name="filtered_shadow_map_2d_light_index"/>
	<parameter type="textureCUBE" name="filtered_shadow_map_cube_tex"/>
	<parameter type="texture2DArray" name="filtered_csm_tex_array"/>
	<parameter type="texture2D" name="filtered_csm_0_tex"/>
	<parameter type="texture2D" name="filtered_csm_1_tex"/>
	<parameter type="texture2D" name="filtered_csm_2_tex"/>
	<parameter type="texture2D" name="filtered_csm_3_tex"/>

	<parameter type="texture2D" name="projective_map_2d_tex"/>
	<parameter type="textureCUBE" name="projective_map_cube_tex"/>

	<parameter type="texture2D" name="shadowing_tex"/>
	<parameter type="texture2D" name="projective_shadowing_tex"/>
	<parameter type="int" name="shadowing_channel"/>

	<parameter type="sampler" name="linear_sampler">
		<state name="filtering" value="min_mag_linear_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>
	<parameter type="sampler" name="aniso_sampler">
		<state name="filtering" value="anisotropic"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
		<state name="max_anisotropy" value="4"/>
	</parameter>

	<parameter type="sampler" name="point_sampler">
		<state name="filtering" value="min_mag_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>

	<parameter type="sampler" name="bilinear_wrap_sampler">
		<state name="filtering" value="min_mag_mip_linear"/>
		<state name="address_u" value="wrap"/>
		<state name="address_v" value="wrap"/>
	</parameter>

	<parameter type="float2" name="inv_width_height"/>
	<parameter type="texture2D" name="g_buffer_rt0_tex"/>
	<parameter type="texture2D" name="depth_tex"/>
	<parameter type="texture2DMS" name="depth_tex_ms"/>

	<shader>
		<![CDATA[
float4 CalcColor(float n_dot_l, float spec, float atten, float3 shadow, float4 light_color, float4 light_attrib)
{
	float2 ds = n_dot_l * atten * float2(1, spec);
	ds *= light_attrib.xy;
	ds = max(ds, 0);
	return ds.xxxy * light_color * float4(shadow, dot(shadow, 1) / 3);
}

float CalcESM(float occluder, float len, float esm_scale_factor)
{
	// Exponential shadow mapping
	return saturate(exp(occluder - esm_scale_factor * len));
}

float4 ESMOmnidirectional(float3 dir_ls, float len, bool has_shadow, bool has_projective, float esm_scale_factor)
{
	dir_ls.y *= -KLAYGE_FLIPPING;
	
	float shadow = 1;
	if (has_shadow)
	{
		float occluder = filtered_shadow_map_cube_tex.SampleLevel(linear_sampler, dir_ls, 0).x;
		shadow = CalcESM(occluder, len, esm_scale_factor);
	}

	float4 projective = 1;
	if (has_projective)
	{
		projective = projective_map_cube_tex.SampleLevel(linear_sampler, dir_ls, 0);
	}
	
	return projective * shadow;
}

float4 ESMDirectional(float3 pos_es, float2 light_proj_pos, float len, bool has_shadow, bool has_projective, int sm_index,
	float esm_scale_factor)
{		
	float shadow = 1;
	if (has_shadow)
	{
#if (KLAYGE_MAX_TEX_ARRAY_LEN >= 4) && (1 == KLAYGE_RENDER_TO_TEX_ARRAY)
		float occluder = filtered_shadow_map_2d_tex_array.SampleLevel(linear_sampler, float3(light_proj_pos, sm_index), 0).x;
#else
		float occluder = filtered_shadow_map_2d_tex.SampleLevel(linear_sampler, light_proj_pos, 0).x;
#endif
		shadow = CalcESM(occluder, len, esm_scale_factor);
	}
	
	float4 projective = 1;
	if (has_projective)
	{
		projective = projective_map_2d_tex.SampleLevel(linear_sampler, light_proj_pos, 0);
	}
	
	return projective * shadow;
}

float4 ESMSun(float3 pos_es, float2 light_proj_pos, float4 tc_ddx_ddy, float len, float esm_scale_factor)
{	
	float shadow = 0;
	if ((pos_es.z >= cascade_intervals[0].x) && (pos_es.z < cascade_intervals[num_cascades - 1].y))
	{
		for (int i = 0; i < num_cascades; ++ i)
		{
			if ((pos_es.z >= cascade_intervals[i].x) && (pos_es.z < cascade_intervals[i].y))
			{
				float2 shadow_tc = light_proj_pos * cascade_scale_bias[i].xy + cascade_scale_bias[i].zw;
				shadow_tc.y = KLAYGE_FLIPPING < 0 ? shadow_tc.y : 1 - shadow_tc.y;

				float4 shadow_tc_ddx_ddy = tc_ddx_ddy * cascade_scale_bias[i].xyxy;

#if (KLAYGE_MAX_TEX_ARRAY_LEN >= 4) && (1 == KLAYGE_RENDER_TO_TEX_ARRAY)
				float occluder = filtered_csm_tex_array.SampleGrad(aniso_sampler, float3(shadow_tc, i),
					shadow_tc_ddx_ddy.xy, shadow_tc_ddx_ddy.zw).x;
#else
				float occluder;
				if (0 == i)
				{
					occluder = filtered_csm_0_tex.SampleGrad(aniso_sampler, shadow_tc,
						shadow_tc_ddx_ddy.xy, shadow_tc_ddx_ddy.zw).x;
				}
				else if (1 == i)
				{
					occluder = filtered_csm_1_tex.SampleGrad(aniso_sampler, shadow_tc,
						shadow_tc_ddx_ddy.xy, shadow_tc_ddx_ddy.zw).x;
				}
				else if (2 == i)
				{
					occluder = filtered_csm_2_tex.SampleGrad(aniso_sampler, shadow_tc,
						shadow_tc_ddx_ddy.xy, shadow_tc_ddx_ddy.zw).x;
				}
				else
				{
					occluder = filtered_csm_3_tex.SampleGrad(aniso_sampler, shadow_tc,
						shadow_tc_ddx_ddy.xy, shadow_tc_ddx_ddy.zw).x;
				}
#endif
				shadow += CalcESM(occluder, len, esm_scale_factor);
			}
		}
	}
	
	return shadow;
}

float4 NearestDepthUpsamplingShadow(float2 tc, float2 tc_ddx, float2 tc_ddy, int channel)
{
	float2 l1_inv_width_height = inv_width_height * 2;
	float2 tc0 = tc - inv_width_height;
	float z00 = depth_tex.SampleGrad(point_sampler, tc0, tc_ddx * 2, tc_ddy * 2).x;
	float z10 = depth_tex.SampleGrad(point_sampler, tc0 + float2(l1_inv_width_height.x, 0), tc_ddx * 2, tc_ddy * 2).x;
	float z01 = depth_tex.SampleGrad(point_sampler, tc0 + float2(0, l1_inv_width_height.y), tc_ddx * 2, tc_ddy * 2).x;
	float z11 = depth_tex.SampleGrad(point_sampler, tc0 + l1_inv_width_height, tc_ddx * 2, tc_ddy * 2).x;
	float z_full = depth_tex.SampleGrad(point_sampler, tc, tc_ddx, tc_ddy).x;
	float threshold = 0.25f;

	float3 ndus = NearestDepthUpsampling(tc0, float4(z00, z10, z01, z11), z_full, l1_inv_width_height, threshold);
	if (ndus.z > 0)
	{
		if (channel < 4)
		{
			return shadowing_tex.SampleGrad(linear_sampler, tc, tc_ddx, tc_ddy)[channel];
		}
		else
		{
			return projective_shadowing_tex.SampleGrad(linear_sampler, tc, tc_ddx, tc_ddy);
		}
	}
	else
	{
		if (channel < 4)
		{
			return shadowing_tex.SampleGrad(point_sampler, ndus.xy, tc_ddx, tc_ddy)[channel];
		}
		else
		{
			return projective_shadowing_tex.SampleGrad(point_sampler, ndus.xy, tc_ddx, tc_ddy);
		}
	}
}

void DeferredRenderingDepthOnlyVS(float4 pos : POSITION,
				out float4 oPos : SV_Position)
{
	oPos = mul(float4(pos.xyz, 1), light_volume_mvp);
}

float4 DeferredRenderingDepthOnlyPS() : SV_Target
{
	return 0;
}

void DeferredRenderingVS(float4 pos : POSITION,
				out SS_TEXCOORD_TYPE oTc : TEXCOORD0,
				out float3 oViewDir : TEXCOORD1,
				out float4 oPos : SV_Position)
{
	oPos = mul(pos, light_volume_mvp);

	oViewDir = mul(pos, light_volume_mv).xyz;
	oTc = EncodeSSTexcoord(oPos);
}

float4 CalcDRLighting(float3 light_pos, float3 pos_es, float3 normal, float3 view_dir,
		float shininess, float2 tc, float atten, float2 tc_ddx, float2 tc_ddy)
{
	float4 lighting = 0;
	float3 dir = light_pos - pos_es;
	float dist = length(dir);
	if (dist < light_falloff_range.w)
	{
		dir /= dist;
		float n_dot_l = dot(normal, dir);
		if (n_dot_l > 0)
		{
			float3 shadow = 1;
			if (shadowing_channel >= 0)
			{
				shadow = NearestDepthUpsamplingShadow(tc, tc_ddx, tc_ddy, shadowing_channel).xyz;
			}

			float spec = DistributionTerm(normalize(dir - view_dir), normal, shininess).x;
			lighting = CalcColor(n_dot_l, spec, atten, shadow, light_color, light_attrib);
		}
	}
	
	return lighting;
}

float4 DeferredRenderingPointPS(
	SS_TEXCOORD_TYPE ss_tc : TEXCOORD0,
	float3 view_dir : TEXCOORD1) : SV_Target
{
	float2 tc = DecodeSSTexcoord(ss_tc);

	float2 tc_ddx = ddx(tc);
	float2 tc_ddy = ddy(tc);

	float4 rt0 = g_buffer_rt0_tex.Sample(point_sampler, tc);

	view_dir = normalize(view_dir);
	float3 pos_es = view_dir * (depth_tex.Sample(point_sampler, tc).x / view_dir.z);
	float3 normal = GetNormal(rt0);
	float shininess = Glossiness2Shininess(GetGlossiness(rt0));
	
	return CalcDRLighting(light_pos_es.xyz, pos_es, normal, view_dir,
		shininess, tc,
		AttenuationTerm(light_pos_es.xyz, pos_es, light_falloff_range.xyz), tc_ddx, tc_ddy);
}

float4 DeferredRenderingSpotPS(
	SS_TEXCOORD_TYPE ss_tc : TEXCOORD0,
	float3 view_dir : TEXCOORD1) : SV_Target
{
	float2 tc = DecodeSSTexcoord(ss_tc);

	float2 tc_ddx = ddx(tc);
	float2 tc_ddy = ddy(tc);

	float4 rt0 = g_buffer_rt0_tex.Sample(point_sampler, tc);
	float4 lighting = 0;
	
	view_dir = normalize(view_dir);
	float3 pos_es = view_dir * (depth_tex.Sample(point_sampler, tc).x / view_dir.z);
	float spot = SpotLighting(light_pos_es.xyz, light_dir_es.xyz,
				float2(light_pos_es.w, light_dir_es.w), pos_es.xyz);
	if (spot > 0)
	{
		float3 normal = GetNormal(rt0);
		float shininess = Glossiness2Shininess(GetGlossiness(rt0));
		
		lighting = CalcDRLighting(light_pos_es.xyz, pos_es, normal, view_dir,
			shininess, tc,
			spot * AttenuationTerm(light_pos_es.xyz, pos_es, light_falloff_range.xyz), tc_ddx, tc_ddy);
	}

	return lighting;
}

float4 DeferredRenderingDirectionalPS(
	SS_TEXCOORD_TYPE ss_tc : TEXCOORD0,
	float3 view_dir : TEXCOORD1) : SV_Target
{
	float2 tc = DecodeSSTexcoord(ss_tc);

	float2 tc_ddx = ddx(tc);
	float2 tc_ddy = ddy(tc);
	
	float4 rt0 = g_buffer_rt0_tex.Sample(point_sampler, tc);
	float4 lighting = 0;
	
	view_dir = normalize(view_dir);

	float3 dir = light_dir_es.xyz;
	float3 normal = GetNormal(rt0);
	float n_dot_l = dot(normal, dir);
	if (n_dot_l > 0)
	{
		float spec = DistributionTerm(normalize(dir - view_dir), normal, Glossiness2Shininess(GetGlossiness(rt0))).x;
		float3 shadow = 1;
		if (shadowing_channel >= 0)
		{
			shadow = NearestDepthUpsamplingShadow(tc, tc_ddx, tc_ddy, shadowing_channel).xyz;
		}
		lighting = CalcColor(n_dot_l, spec, 1, shadow, light_color, light_attrib);
	}

	return lighting;
}

float4 DeferredRenderingAmbientPS(
	SS_TEXCOORD_TYPE ss_tc : TEXCOORD0
	) : SV_Target
{
	float2 tc = DecodeSSTexcoord(ss_tc);

	float4 rt0 = g_buffer_rt0_tex.Sample(point_sampler, tc);
	float3 normal = GetNormal(rt0);

	return CalcColor(0.5f + 0.5f * dot(light_dir_es.xyz, normal), 0, 1, 1, light_color, light_attrib);
}

float4 DeferredRenderingSphereAreaPS(
	SS_TEXCOORD_TYPE ss_tc : TEXCOORD0,
	float3 view_dir : TEXCOORD1) : SV_Target
{
	float2 tc = DecodeSSTexcoord(ss_tc);

	float2 tc_ddx = ddx(tc);
	float2 tc_ddy = ddy(tc);

	float4 rt0 = g_buffer_rt0_tex.Sample(point_sampler, tc);

	view_dir = normalize(view_dir);
	float3 pos_es = view_dir * (depth_tex.Sample(point_sampler, tc).x / view_dir.z);
	float3 normal = GetNormal(rt0);
	float shininess = Glossiness2Shininess(GetGlossiness(rt0));
	
	float3 light_pos = SphereAreaLightPositionFixup(light_pos_es.xyz, light_radius_extend.x, pos_es,
		normal, view_dir);
	shininess = AreaLightShininessFixup(shininess, light_pos_es.xyz, light_radius_extend.x, pos_es);
	return CalcDRLighting(light_pos, pos_es, normal, view_dir,
		shininess, tc,
		AttenuationTerm(light_pos_es.xyz, pos_es, light_falloff_range.xyz), tc_ddx, tc_ddy);
}

float4 DeferredRenderingTubeAreaPS(
	SS_TEXCOORD_TYPE ss_tc : TEXCOORD0,
	float3 view_dir : TEXCOORD1) : SV_Target
{
	float2 tc = DecodeSSTexcoord(ss_tc);

	float2 tc_ddx = ddx(tc);
	float2 tc_ddy = ddy(tc);

	float4 rt0 = g_buffer_rt0_tex.Sample(point_sampler, tc);

	view_dir = normalize(view_dir);
	float3 pos_es = view_dir * (depth_tex.Sample(point_sampler, tc).x / view_dir.z);
	float3 normal = GetNormal(rt0);
	float shininess = Glossiness2Shininess(GetGlossiness(rt0));
	
	float3 l0 = light_pos_es.xyz - light_radius_extend.yzw - pos_es;
	float3 l1 = light_pos_es.xyz + light_radius_extend.yzw - pos_es;
	float3 light_pos = TubeAreaLightPositionFixup(l0, l1, pos_es, normal, view_dir);
	float2 atten_irra_factor = TubeAreaLightAttenuationIrradianceFixup(l0, l1, normal);
	shininess = AreaLightShininessFixup(shininess, light_pos_es.xyz, light_radius_extend.x, pos_es);
	return CalcDRLighting(light_pos, pos_es, normal, view_dir,
		shininess, tc, atten_irra_factor.x * atten_irra_factor.y, tc_ddx, tc_ddy);
}

float4 DeferredShadowingPointPS(
	SS_TEXCOORD_TYPE ss_tc : TEXCOORD0,
	float3 view_dir : TEXCOORD1) : SV_Target
{
	float2 tc = DecodeSSTexcoord(ss_tc);

	view_dir = normalize(view_dir);
	float3 pos_es = view_dir * (depth_tex.Sample(point_sampler, tc).x / view_dir.z);
	float3 dir = light_pos_es.xyz - pos_es;
	float len = length(dir);
	float3 dir_ls = mul(-dir, (float3x3)view_to_light_model);
	return ESMOmnidirectional(dir_ls, len, light_attrib.z > 0, light_attrib.w > 0, esm_scale_factor);
}

float4 DeferredShadowingSpotPS(
	SS_TEXCOORD_TYPE ss_tc : TEXCOORD0,
	float3 view_dir : TEXCOORD1) : SV_Target
{
	float2 tc = DecodeSSTexcoord(ss_tc);

	view_dir = normalize(view_dir);
	float3 pos_es = view_dir * (depth_tex.Sample(point_sampler, tc).x / view_dir.z);
	float4 light_proj_pos = mul(float4(pos_es, 1), light_view_proj);
	light_proj_pos /= light_proj_pos.w;
	light_proj_pos.y *= KLAYGE_FLIPPING;
	light_proj_pos.xy = light_proj_pos.xy * 0.5f + 0.5f;
	float len = length(light_pos_es.xyz - pos_es);	
	return ESMDirectional(pos_es, light_proj_pos.xy, len, light_attrib.z > 0, light_attrib.w > 0, filtered_shadow_map_2d_light_index,
		esm_scale_factor);
}

float4 DeferredShadowingDirectionalPS(
	SS_TEXCOORD_TYPE ss_tc : TEXCOORD0,
	float3 view_dir : TEXCOORD1) : SV_Target
{
	float2 tc = DecodeSSTexcoord(ss_tc);

	view_dir = normalize(view_dir);
	float3 pos_es = view_dir * (depth_tex.Sample(point_sampler, tc).x / view_dir.z);
	float2 light_proj_pos = mul(float4(pos_es, 1), light_view_proj).xy;
	light_proj_pos.y *= -1;
	light_proj_pos = light_proj_pos * 0.5f + 0.5f;
	float4 tc_ddx_ddy = float4(ddx(light_proj_pos), ddy(light_proj_pos));
	float len = dot(float4(pos_es, 1), view_z_to_light_view);
	return ESMSun(pos_es, light_proj_pos, tc_ddx_ddy, len, esm_scale_factor);
}
		]]>
	</shader>

	<technique name="DeferredRenderingLightDepthOnly">
		<pass name="p0">
			<state name="depth_enable" value="true"/>
			<state name="depth_func" value="greater_equal"/>
			<state name="depth_write_mask" value="false"/>

			<state name="color_write_mask" value="0"/>

			<state name="depth_clip_enable" value="false"/>
			<state name="cull_mode" value="front"/>

			<state name="vertex_shader" value="DeferredRenderingDepthOnlyVS()"/>
			<state name="pixel_shader" value="DeferredRenderingDepthOnlyPS()"/>
		</pass>
	</technique>

	<technique name="DeferredRenderingLightStencil">
		<pass name="p0">
			<state name="depth_enable" value="true"/>
			<state name="depth_func" value="less"/>
			<state name="depth_write_mask" value="false"/>

			<state name="color_write_mask" value="0"/>

			<state name="depth_clip_enable" value="false"/>
			<state name="cull_mode" value="none"/>

			<state name="front_stencil_enable" value="true"/>
			<state name="front_stencil_func" value="equal"/>
			<state name="front_stencil_ref" value="0"/>
			<state name="front_stencil_depth_fail" value="decr"/>
			<state name="back_stencil_enable" value="true"/>
			<state name="back_stencil_func" value="equal"/>
			<state name="back_stencil_ref" value="0"/>
			<state name="back_stencil_depth_fail" value="incr"/>

			<state name="vertex_shader" value="DeferredRenderingDepthOnlyVS()"/>
			<state name="pixel_shader" value="DeferredRenderingDepthOnlyPS()"/>
		</pass>
	</technique>

	<technique name="DeferredRenderingPoint">
		<pass name="p0">
			<state name="depth_enable" value="false"/>
			<state name="depth_write_mask" value="false"/>

			<state name="depth_clip_enable" value="false"/>
			<state name="cull_mode" value="front"/>

			<state name="front_stencil_enable" value="true"/>
			<state name="front_stencil_func" value="less"/>
			<state name="front_stencil_ref" value="0"/>
			<state name="front_stencil_pass" value="replace"/>
			<state name="front_stencil_read_mask" value="127"/>
			<state name="front_stencil_write_mask" value="127"/>
			<state name="back_stencil_enable" value="true"/>
			<state name="back_stencil_func" value="less"/>
			<state name="back_stencil_ref" value="0"/>
			<state name="back_stencil_pass" value="replace"/>
			<state name="back_stencil_read_mask" value="127"/>
			<state name="back_stencil_write_mask" value="127"/>

			<state name="blend_enable" value="true"/>
			<state name="blend_op" value="add"/>
			<state name="src_blend" value="one"/>
			<state name="dest_blend" value="one"/>
			<state name="blend_op_alpha" value="add"/>
			<state name="src_blend_alpha" value="one"/>
			<state name="dest_blend_alpha" value="one"/>

			<state name="vertex_shader" value="DeferredRenderingVS()"/>
			<state name="pixel_shader" value="DeferredRenderingPointPS()"/>
		</pass>
	</technique>

	<technique name="DeferredRenderingSpot" inherit="DeferredRenderingPoint">
		<pass name="p0">
			<state name="pixel_shader" value="DeferredRenderingSpotPS()"/>
		</pass>
	</technique>

	<technique name="DeferredRenderingDirectional" inherit="DeferredRenderingPoint">
		<pass name="p0">
			<state name="front_stencil_func" value="equal"/>
			<state name="front_stencil_pass" value="keep"/>
			<state name="front_stencil_read_mask" value="128"/>
			<state name="front_stencil_write_mask" value="0"/>
			<state name="back_stencil_func" value="equal"/>
			<state name="back_stencil_pass" value="keep"/>
			<state name="back_stencil_read_mask" value="128"/>
			<state name="back_stencil_write_mask" value="0"/>

			<state name="pixel_shader" value="DeferredRenderingDirectionalPS()"/>
		</pass>
	</technique>
			
	<technique name="DeferredRenderingAmbient" inherit="DeferredRenderingDirectional">
		<pass name="p0">
			<state name="blend_enable" value="false"/>

			<state name="pixel_shader" value="DeferredRenderingAmbientPS()"/>
		</pass>
	</technique>

	<technique name="DeferredRenderingSphereArea" inherit="DeferredRenderingPoint">
		<pass name="p0">
			<state name="pixel_shader" value="DeferredRenderingSphereAreaPS()"/>
		</pass>
	</technique>

	<technique name="DeferredRenderingTubeArea" inherit="DeferredRenderingPoint">
		<pass name="p0">
			<state name="pixel_shader" value="DeferredRenderingTubeAreaPS()"/>
		</pass>
	</technique>

	<technique name="DeferredShadowingPoint">
		<pass name="p0">
			<state name="depth_enable" value="true"/>
			<state name="depth_func" value="greater_equal"/>
			<state name="depth_write_mask" value="false"/>

			<state name="depth_clip_enable" value="false"/>
			<state name="cull_mode" value="front"/>

			<state name="vertex_shader" value="DeferredRenderingVS()"/>
			<state name="pixel_shader" value="DeferredShadowingPointPS()"/>
		</pass>
	</technique>
	<technique name="DeferredShadowingPointR" inherit="DeferredShadowingPoint">
		<pass name="p0">
			<state name="color_write_mask" value="1"/>
		</pass>
	</technique>
	<technique name="DeferredShadowingPointG" inherit="DeferredShadowingPoint">
		<pass name="p0">
			<state name="color_write_mask" value="2"/>
		</pass>
	</technique>
	<technique name="DeferredShadowingPointB" inherit="DeferredShadowingPoint">
		<pass name="p0">
			<state name="color_write_mask" value="4"/>
		</pass>
	</technique>
	<technique name="DeferredShadowingPointA" inherit="DeferredShadowingPoint">
		<pass name="p0">
			<state name="color_write_mask" value="8"/>
		</pass>
	</technique>

	<technique name="DeferredShadowingSpot" inherit="DeferredShadowingPoint">
		<pass name="p0">
			<state name="pixel_shader" value="DeferredShadowingSpotPS()"/>
		</pass>
	</technique>
	<technique name="DeferredShadowingSpotR" inherit="DeferredShadowingSpot">
		<pass name="p0">
			<state name="color_write_mask" value="1"/>
		</pass>
	</technique>
	<technique name="DeferredShadowingSpotG" inherit="DeferredShadowingSpot">
		<pass name="p0">
			<state name="color_write_mask" value="2"/>
		</pass>
	</technique>
	<technique name="DeferredShadowingSpotB" inherit="DeferredShadowingSpot">
		<pass name="p0">
			<state name="color_write_mask" value="4"/>
		</pass>
	</technique>
	<technique name="DeferredShadowingSpotA" inherit="DeferredShadowingSpot">
		<pass name="p0">
			<state name="color_write_mask" value="8"/>
		</pass>
	</technique>

	<technique name="DeferredShadowingDirectional" inherit="DeferredShadowingPoint">
		<pass name="p0">
			<state name="pixel_shader" value="DeferredShadowingDirectionalPS()"/>
		</pass>
	</technique>
	<technique name="DeferredShadowingDirectionalR" inherit="DeferredShadowingDirectional">
		<pass name="p0">
			<state name="color_write_mask" value="1"/>
		</pass>
	</technique>
	<technique name="DeferredShadowingDirectionalG" inherit="DeferredShadowingDirectionalR">
		<pass name="p0">
			<state name="color_write_mask" value="2"/>
		</pass>
	</technique>
	<technique name="DeferredShadowingDirectionalB" inherit="DeferredShadowingDirectionalR">
		<pass name="p0">
			<state name="color_write_mask" value="4"/>
		</pass>
	</technique>
	<technique name="DeferredShadowingDirectionalA" inherit="DeferredShadowingDirectionalR">
		<pass name="p0">
			<state name="color_write_mask" value="8"/>
		</pass>
	</technique>


	<parameter type="texture2D" name="lighting_tex"/>
	<parameter type="texture2D" name="g_buffer_rt1_tex"/>
	<parameter type="texture2D" name="g_buffer_rt2_tex"/>
	<parameter type="texture2D" name="shading_tex"/>
	<parameter type="texture2DMS" name="shading_tex_ms"/>

	<parameter type="float2" name="near_q"/>

	<parameter type="float4x4" name="inv_view"/>
	<parameter type="int3" name="skylight_diff_spec_mip"/>
	<parameter type="textureCUBE" name="skylight_y_cube_tex"/>
	<parameter type="textureCUBE" name="skylight_c_cube_tex"/>
	<parameter type="sampler" name="skylight_sampler">
		<state name="filtering" value="min_mag_mip_linear"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
		<state name="address_w" value="clamp"/>
	</parameter>

	<shader>
		<![CDATA[
float4 SkylightShading(float glossiness, float3 c_diff, float3 c_spec, float3 normal, float3 view)
{
	float4 shading = 0;
	
	if (skylight_diff_spec_mip.z)
	{
		normal = mul(normal, (float3x3)inv_view);
		view = mul(view, (float3x3)inv_view);

		float3 prefiltered_clr = decode_hdr_yc(skylight_y_cube_tex.SampleLevel(skylight_sampler, normal, skylight_diff_spec_mip.x).r,
			skylight_c_cube_tex.SampleLevel(skylight_sampler, normal, skylight_diff_spec_mip.x)).xyz;
		shading.xyz += CalcEnvDiffuse(prefiltered_clr, c_diff);

		float mip = CalcPrefilteredEnvMip(glossiness, skylight_diff_spec_mip.y);
		float3 r = CalcPrefilteredEnvVec(normal, view);
		prefiltered_clr = decode_hdr_yc(skylight_y_cube_tex.SampleLevel(skylight_sampler, r, mip).r,
			skylight_c_cube_tex.SampleLevel(skylight_sampler, r, mip)).xyz;
		shading.xyz += CalcEnvSpecular(prefiltered_clr, c_spec, glossiness, normal, view);
	}
	
	return shading;
}

void ShadingVS(float4 pos : POSITION,
			out float2 oTexCoord : TEXCOORD0,
			out float3 oViewDir : TEXCOORD1,
			out float4 oPos : SV_Position)
{
	oPos = pos;

	oViewDir = -mul(pos, light_volume_mv).xyz;
	oTexCoord = pos.xy / 2;
	oTexCoord.y *= KLAYGE_FLIPPING;
	oTexCoord += 0.5f;
}

float4 NoLightingPS(float2 tc : TEXCOORD0) : SV_Target
{
	return g_buffer_rt1_tex.Sample(point_sampler, tc);
}

float4 ShadingPS(float2 tc : TEXCOORD0, float3 view_dir : TEXCOORD1) : SV_Target
{
	float4 rt0 = g_buffer_rt0_tex.Sample(point_sampler, tc);
	float glossiness = GetGlossiness(rt0);
	float shininess = Glossiness2Shininess(glossiness);
	float3 normal = GetNormal(rt0);
	
	float4 lighting = lighting_tex.Sample(point_sampler, tc);
	float4 rt1 = g_buffer_rt1_tex.Sample(point_sampler, tc);
	float3 c_diff = GetDiffuse(rt1);
	float3 c_spec = GetSpecular(rt1);
	float4 shading = float4(CalcShading(lighting, shininess, c_diff, c_spec, view_dir, normal), 1);
	shading += SkylightShading(glossiness, c_diff, c_spec, normal, view_dir);

	float4 rt2 = g_buffer_rt2_tex.Sample(point_sampler, tc);
	float occlusion = GetOcclusion(rt2);
	
	return shading * float4(occlusion.xxx, 1);
}

float4 MergeShadingPS(float2 tc : TEXCOORD0, uint sample_index : SV_SampleIndex) : SV_Target
{
#if KLAYGE_EXPLICIT_MULTI_SAMPLE_SUPPORT && MULTI_SAMPLE_INPUT
	uint width, height, samples;
	shading_tex_ms.GetDimensions(width, height, samples);
	int2 coord = tc * int2(width, height);
	return shading_tex_ms.Load(coord, sample_index);
#else
	return shading_tex.Sample(point_sampler, tc);
#endif
}

float4 MergeDepthPS(float2 tc : TEXCOORD0, uint sample_index : SV_SampleIndex) : SV_Target
{
#if KLAYGE_EXPLICIT_MULTI_SAMPLE_SUPPORT && MULTI_SAMPLE_INPUT
	uint width, height, samples;
	depth_tex_ms.GetDimensions(width, height, samples);
	int2 coord = tc * int2(width, height);
	return depth_tex_ms.Load(coord, sample_index);
#else
	return depth_tex.Sample(point_sampler, tc);
#endif
}

#if !KLAYGE_OPENGLES
void CopyShadingDepthPS(float2 tc : TEXCOORD0,
		out float4 oClr : SV_Target0, out float oDepth : SV_Depth)
{
	oClr = shading_tex.Sample(point_sampler, tc);
	oDepth = linear_depth_to_non_linear(depth_tex.Sample(point_sampler, tc).x, near_q.x, near_q.y);
}
#else
void CopyShadingDepthPS(float2 tc : TEXCOORD0,
		out float4 oClr : SV_Target0)
{
	oClr = shading_tex.Sample(point_sampler, tc);
}
#endif
		]]>
	</shader>

	<technique name="NoLightingTech">
		<pass name="p0">
			<state name="depth_enable" value="false"/>
			<state name="depth_write_mask" value="false"/>

			<state name="cull_mode" value="front"/>

			<state name="front_stencil_enable" value="true"/>
			<state name="front_stencil_func" value="not_equal"/>
			<state name="front_stencil_ref" value="0"/>
			<state name="front_stencil_pass" value="keep"/>
			<state name="front_stencil_read_mask" value="144"/>	<!--128 is no lighting, 16 is transparent-->
			<state name="back_stencil_enable" value="true"/>
			<state name="back_stencil_func" value="not_equal"/>
			<state name="back_stencil_ref" value="0"/>
			<state name="back_stencil_pass" value="keep"/>
			<state name="back_stencil_read_mask" value="144"/>

			<state name="vertex_shader" value="ShadingVS()"/>
			<state name="pixel_shader" value="NoLightingPS()"/>
		</pass>
	</technique>

	<technique name="ShadingTech">
		<pass name="p0">
			<state name="depth_enable" value="false"/>
			<state name="depth_write_mask" value="false"/>

			<state name="cull_mode" value="front"/>

			<state name="front_stencil_enable" value="true"/>
			<state name="front_stencil_func" value="not_equal"/>
			<state name="front_stencil_ref" value="128"/>
			<state name="front_stencil_pass" value="keep"/>
			<state name="back_stencil_enable" value="true"/>
			<state name="back_stencil_func" value="not_equal"/>
			<state name="back_stencil_ref" value="128"/>
			<state name="back_stencil_pass" value="keep"/>

			<state name="vertex_shader" value="ShadingVS()"/>
			<state name="pixel_shader" value="ShadingPS()"/>
		</pass>
	</technique>

	<technique name="MergeShadingAlphaBlendTech">
		<pass name="p0">
			<state name="cull_mode" value="front"/>
			<state name="depth_enable" value="false"/>
			<state name="depth_write_mask" value="false"/>

			<state name="blend_enable" value="true"/>
			<state name="blend_op" value="add"/>
			<state name="src_blend" value="src_alpha"/>
			<state name="dest_blend" value="inv_src_alpha"/>
			<state name="blend_op_alpha" value="add"/>
			<state name="src_blend_alpha" value="one"/>
			<state name="dest_blend_alpha" value="one"/>

			<state name="front_stencil_enable" value="true"/>
			<state name="front_stencil_func" value="not_equal"/>
			<state name="front_stencil_ref" value="16"/>
			<state name="front_stencil_pass" value="keep"/>
			<state name="back_stencil_enable" value="true"/>
			<state name="back_stencil_func" value="not_equal"/>
			<state name="back_stencil_ref" value="16"/>
			<state name="back_stencil_pass" value="keep"/>

			<state name="vertex_shader" value="ShadingVS()"/>
			<state name="pixel_shader" value="MergeShadingPS()"/>
		</pass>
	</technique>
	<technique name="MergeShadingAlphaBlendMSTech" inherit="MergeShadingAlphaBlendTech">
		<macro name="MULTI_SAMPLE_INPUT" value="1"/>
	</technique>

	<technique name="MergeDepthAlphaBlendTech">
		<pass name="p0">
			<state name="cull_mode" value="front"/>
			<state name="depth_enable" value="false"/>
			<state name="depth_write_mask" value="false"/>

			<state name="front_stencil_enable" value="true"/>
			<state name="front_stencil_func" value="not_equal"/>
			<state name="front_stencil_ref" value="16"/>
			<state name="front_stencil_pass" value="keep"/>
			<state name="back_stencil_enable" value="true"/>
			<state name="back_stencil_func" value="not_equal"/>
			<state name="back_stencil_ref" value="16"/>
			<state name="back_stencil_pass" value="keep"/>

			<state name="vertex_shader" value="ShadingVS()"/>
			<state name="pixel_shader" value="MergeDepthPS()"/>
		</pass>
	</technique>
	<technique name="MergeDepthAlphaBlendMSTech" inherit="MergeDepthAlphaBlendTech">
		<macro name="MULTI_SAMPLE_INPUT" value="1"/>
	</technique>

	<technique name="CopyShadingDepthTech">
		<pass name="p0">
			<state name="cull_mode" value="front"/>
			<state name="depth_enable" value="true"/>
			<state name="depth_func" value="always_pass"/>

			<state name="vertex_shader" value="ShadingVS()"/>
			<state name="pixel_shader" value="CopyShadingDepthPS()"/>
		</pass>
	</technique>
</effect>
